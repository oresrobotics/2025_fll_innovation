<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D GLB Model Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            z-index: 10;
            max-width: 320px;
            transition: all 0.3s ease;
        }

        #controls.collapsed {
            padding: 10px 20px;
        }

        #controls.collapsed .controls-content {
            display: none;
        }

        .controls-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        #controls.collapsed .controls-header {
            margin-bottom: 0;
        }

        #toggleMenu {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            padding: 5px;
            width: auto;
            margin: 0;
        }

        #toggleMenu:hover {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 4px;
        }

        h1 {
            font-size: 20px;
            margin-bottom: 15px;
            color: #333;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
            margin-bottom: 15px;
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }

        .file-input-label {
            display: block;
            padding: 12px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            text-align: center;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .file-input-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 5px;
            color: #555;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
        }

        button {
            width: 100%;
            padding: 10px;
            background: #f0f0f0;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            color: #333;
            transition: background 0.2s;
            margin-bottom: 8px;
        }

        button:hover {
            background: #e0e0e0;
        }

        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 6px;
            backdrop-filter: blur(10px);
        }

        #partInfo {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: white;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 6px;
            backdrop-filter: blur(10px);
            display: none;
        }

        #partInfo.visible {
            display: block;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            font-weight: 600;
            display: none;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px 40px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        
        <div id="controls">
            <div class="controls-header">
                <h1>üé® 3D Model Viewer</h1>
                <button id="toggleMenu">‚ñº</button>
            </div>
            
            <div class="controls-content">
                <div class="file-input-wrapper">
                    <input type="file" id="fileInput" accept=".glb,.gltf">
                    <label for="fileInput" class="file-input-label">
                        üìÅ Load GLB Model
                    </label>
                </div>

                <div class="control-group">
                    <label>Auto-Rotation Speed</label>
                    <input type="range" id="rotationSpeed" min="0" max="2" step="0.1" value="0.5">
                </div>

                <div class="control-group">
                    <label>Zoom</label>
                    <input type="range" id="zoom" min="1" max="10" step="0.1" value="5" style="direction: rtl;">
                </div>

                <button id="resetCamera">Reset Camera</button>
                <button id="resetOrientation">Reset Orientation</button>
                <button id="toggleAutoRotate">Auto-Rotate: ON</button>
                <button id="toggle360Camera">360¬∞ Camera: OFF</button>
                <button id="rotatePlatform">Rotate Platform</button>
                <button id="explodeModel">Explode Model</button>
                <button id="assembleModel">Assemble Model</button>
                <button id="toggleMoveMode">Move Mode: OFF</button>
                <button id="toggleWireframe">Toggle Wireframe</button>
                <button id="toggleGrid">Toggle Grid</button>
            </div>
        </div>

        <div id="loading">Loading model...</div>
        
        <div id="info">
            üñ±Ô∏è Left click + drag to rotate<br>
            üñ±Ô∏è Right click + drag to pan<br>
            üñ±Ô∏è Scroll to zoom
        </div>

        <div id="partInfo">
            <strong>Selected Part:</strong><br>
            <span id="partName">None</span><br>
            <strong>Position:</strong><br>
            X: <span id="partX">0.00</span><br>
            Y: <span id="partY">0.00</span><br>
            Z: <span id="partZ">0.00</span>
        </div>
    </div>

    <script>
        let scene, camera, renderer, model, grid;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let rotationSpeed = 0.5;
        let autoRotate = true;
        let wireframeMode = false;
        let isExploded = false;
        let originalPositions = [];
        let moveMode = false;
        let selectedObject = null;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let platformRotateMode = false;
        let platform;
        let camera360Mode = false;
        let camera360Angle = 0;
        let camera360Radius = 5;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 5);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('canvas'),
                antialias: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            const pointLight1 = new THREE.PointLight(0x667eea, 0.5);
            pointLight1.position.set(-5, 5, -5);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0x764ba2, 0.5);
            pointLight2.position.set(5, 5, 5);
            scene.add(pointLight2);

            platform = new THREE.Group();
            scene.add(platform);

            grid = new THREE.GridHelper(10, 10, 0x667eea, 0x444444);
            platform.add(grid);

            setupEventListeners();
            animate();
        }

        function setupEventListeners() {
            document.getElementById('toggleMenu').addEventListener('click', () => {
                const controls = document.getElementById('controls');
                const toggleBtn = document.getElementById('toggleMenu');
                controls.classList.toggle('collapsed');
                toggleBtn.textContent = controls.classList.contains('collapsed') ? '‚ñ≤' : '‚ñº';
            });

            document.getElementById('fileInput').addEventListener('change', handleFileSelect);
            document.getElementById('rotationSpeed').addEventListener('input', (e) => {
                rotationSpeed = parseFloat(e.target.value);
            });
            document.getElementById('zoom').addEventListener('input', (e) => {
                camera.position.z = parseFloat(e.target.value);
            });
            document.getElementById('resetCamera').addEventListener('click', () => {
                camera.position.set(0, 2, 5);
                camera.lookAt(0, 0, 0);
            });
            document.getElementById('resetOrientation').addEventListener('click', () => {
                if (model) {
                    model.rotation.set(0, 0, 0);
                }
            });
            document.getElementById('toggleAutoRotate').addEventListener('click', toggleAutoRotate);
            document.getElementById('toggle360Camera').addEventListener('click', toggle360Camera);
            document.getElementById('rotatePlatform').addEventListener('click', togglePlatformRotate);
            document.getElementById('explodeModel').addEventListener('click', explodeModel);
            document.getElementById('assembleModel').addEventListener('click', assembleModel);
            document.getElementById('toggleMoveMode').addEventListener('click', toggleMoveMode);
            document.getElementById('toggleWireframe').addEventListener('click', toggleWireframe);
            document.getElementById('toggleGrid').addEventListener('click', () => {
                grid.visible = !grid.visible;
            });

            const canvas = document.getElementById('canvas');
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('wheel', onWheel);

            window.addEventListener('resize', onWindowResize);
        }

        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (!file) return;

            document.getElementById('loading').style.display = 'block';

            const reader = new FileReader();
            reader.onload = function(event) {
                loadGLB(event.target.result);
            };
            reader.readAsArrayBuffer(file);
        }

        function loadGLB(data) {
            const loader = new THREE.GLTFLoader();
            
            loader.parse(data, '', function(gltf) {
                if (model) {
                    platform.remove(model);
                }

                model = gltf.scene;
                
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                
                model.position.sub(center);
                
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 2 / maxDim;
                model.scale.multiplyScalar(scale);

                model.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });

                storeOriginalPositions();
                platform.add(model);
                document.getElementById('loading').style.display = 'none';
                
            }, function(error) {
                console.error('Error loading GLB:', error);
                document.getElementById('loading').style.display = 'none';
                alert('Error loading model. Please check the file format.');
            });
        }

        function toggleWireframe() {
            wireframeMode = !wireframeMode;
            if (model) {
                model.traverse((child) => {
                    if (child.isMesh) {
                        child.material.wireframe = wireframeMode;
                    }
                });
            }
        }

        function storeOriginalPositions() {
            originalPositions = [];
            if (model) {
                model.traverse((child) => {
                    if (child.isMesh || child.isGroup) {
                        originalPositions.push({
                            object: child,
                            position: child.position.clone()
                        });
                    }
                });
            }
        }

        function explodeModel() {
            if (!model || isExploded) return;
            isExploded = true;

            const center = new THREE.Vector3(0, 0, 0);

            model.traverse((child) => {
                if (child.isMesh) {
                    const worldPos = new THREE.Vector3();
                    child.getWorldPosition(worldPos);
                    
                    const direction = worldPos.clone().sub(center);
                    if (direction.length() < 0.01) {
                        direction.set(
                            Math.random() - 0.5,
                            Math.random() - 0.5,
                            Math.random() - 0.5
                        ).normalize();
                    } else {
                        direction.normalize();
                    }
                    
                    const distance = 2;
                    const offset = direction.multiplyScalar(distance);
                    child.position.add(offset);
                }
            });
        }

        function assembleModel() {
            if (!model) return;
            isExploded = false;

            originalPositions.forEach(item => {
                item.object.position.copy(item.position);
            });

            // Turn off move mode when assembling
            if (moveMode) {
                moveMode = false;
                const btn = document.getElementById('toggleMoveMode');
                btn.textContent = 'Move Mode: OFF';
                btn.style.background = '#f0f0f0';
                btn.style.color = '#333';
                selectedObject = null;
                document.getElementById('canvas').style.cursor = 'default';
                hidePartInfo();
            }
        }

        function toggleMoveMode() {
            moveMode = !moveMode;
            const btn = document.getElementById('toggleMoveMode');
            btn.textContent = 'Move Mode: ' + (moveMode ? 'ON' : 'OFF');
            btn.style.background = moveMode ? '#667eea' : '#f0f0f0';
            btn.style.color = moveMode ? 'white' : '#333';
            selectedObject = null;
            document.getElementById('canvas').style.cursor = moveMode ? 'pointer' : 'default';
        }

        function toggleAutoRotate() {
            autoRotate = !autoRotate;
            const btn = document.getElementById('toggleAutoRotate');
            btn.textContent = 'Auto-Rotate: ' + (autoRotate ? 'ON' : 'OFF');
            btn.style.background = autoRotate ? '#f0f0f0' : '#667eea';
            btn.style.color = autoRotate ? '#333' : 'white';
        }

        function toggle360Camera() {
            camera360Mode = !camera360Mode;
            const btn = document.getElementById('toggle360Camera');
            btn.textContent = '360¬∞ Camera: ' + (camera360Mode ? 'ON' : 'OFF');
            btn.style.background = camera360Mode ? '#667eea' : '#f0f0f0';
            btn.style.color = camera360Mode ? 'white' : '#333';
            
            if (camera360Mode) {
                camera360Radius = Math.sqrt(
                    camera.position.x * camera.position.x + 
                    camera.position.z * camera.position.z
                );
                camera360Angle = Math.atan2(camera.position.z, camera.position.x);
            }
        }

        function togglePlatformRotate() {
            platformRotateMode = !platformRotateMode;
            moveMode = false;
            const moveBtn = document.getElementById('toggleMoveMode');
            moveBtn.textContent = 'Move Mode: OFF';
            moveBtn.style.background = '#f0f0f0';
            moveBtn.style.color = '#333';
            
            const btn = document.getElementById('rotatePlatform');
            btn.textContent = platformRotateMode ? 'Platform Rotate: ON' : 'Rotate Platform';
            btn.style.background = platformRotateMode ? '#667eea' : '#f0f0f0';
            btn.style.color = platformRotateMode ? 'white' : '#333';
            
            selectedObject = null;
            document.getElementById('canvas').style.cursor = platformRotateMode ? 'grab' : 'default';
        }

        function onMouseDown(e) {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };

            if (platformRotateMode) {
                document.getElementById('canvas').style.cursor = 'grabbing';
            } else if (moveMode && model) {
                const rect = canvas.getBoundingClientRect();
                mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                
                const meshes = [];
                model.traverse((child) => {
                    if (child.isMesh) {
                        meshes.push(child);
                    }
                });
                
                const intersects = raycaster.intersectObjects(meshes, false);

                if (intersects.length > 0) {
                    selectedObject = intersects[0].object;
                    document.getElementById('canvas').style.cursor = 'move';
                    console.log('Selected object:', selectedObject.name || 'unnamed');
                    updatePartInfo();
                } else {
                    selectedObject = null;
                    console.log('No object selected');
                    hidePartInfo();
                }
            }
        }

        function onMouseMove(e) {
            if (!isDragging) return;

            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;

            if (platformRotateMode) {
                platform.rotation.y += deltaX * 0.01;
            } else if (moveMode && selectedObject) {
                const movementScale = 0.01;
                selectedObject.position.z += deltaX * movementScale;
                selectedObject.position.y -= deltaY * movementScale;
                updatePartInfo();
            } else if (!moveMode && model) {
                if (e.buttons === 1) {
                    model.rotation.y += deltaX * 0.01;
                    model.rotation.x += deltaY * 0.01;
                } else if (e.buttons === 2) {
                    camera.position.x -= deltaX * 0.01;
                    camera.position.y += deltaY * 0.01;
                }
            }

            previousMousePosition = { x: e.clientX, y: e.clientY };
        }

        function onMouseUp() {
            isDragging = false;
            if (platformRotateMode) {
                document.getElementById('canvas').style.cursor = 'grab';
            } else if (moveMode && selectedObject) {
                selectedObject = null;
                document.getElementById('canvas').style.cursor = 'pointer';
                hidePartInfo();
            }
        }

        function updatePartInfo() {
            if (selectedObject) {
                document.getElementById('partInfo').classList.add('visible');
                document.getElementById('partName').textContent = selectedObject.name || 'Unnamed Part';
                document.getElementById('partX').textContent = selectedObject.position.x.toFixed(2);
                document.getElementById('partY').textContent = selectedObject.position.y.toFixed(2);
                document.getElementById('partZ').textContent = selectedObject.position.z.toFixed(2);
            }
        }

        function hidePartInfo() {
            document.getElementById('partInfo').classList.remove('visible');
        }

        function onWheel(e) {
            e.preventDefault();
            camera.position.z += e.deltaY * 0.01;
            camera.position.z = Math.max(1, Math.min(10, camera.position.z));
            document.getElementById('zoom').value = camera.position.z;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (model && autoRotate) {
                model.rotation.y += rotationSpeed * 0.01;
            }

            if (camera360Mode) {
                camera360Angle += 0.01;
                camera.position.x = Math.cos(camera360Angle) * camera360Radius;
                camera.position.z = Math.sin(camera360Angle) * camera360Radius;
                camera.lookAt(0, 0, 0);
            }

            renderer.render(scene, camera);
        }

        document.addEventListener('contextmenu', (e) => e.preventDefault());

        init();
    </script>
</body>
</html>
