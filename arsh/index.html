<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple 3D Viewer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #1a1a1a;
            color: #fff;
        }
        canvas {
            display: block;
        }
        #controls-container {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #file-input {
            color: white;
        }
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #ccc;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            max-width: 250px;
        }
        .control-button {
            padding: 8px 15px;
            border: none;
            border-radius: 4px;
            background-color: #007bff;
            color: white;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .control-button:hover {
            background-color: #0056b3;
        }
    </style>
</head>
<body>

    <div id="controls-container">
        <input type="file" id="file-input" accept=".glb, .gltf" multiple title="Load 3D models">
        <button id="clear-button" class="control-button">Clear Models</button>
        <button id="undo-button" class="control-button" disabled>Undo Rotate</button>
        <button id="redo-button" class="control-button" disabled>Redo Rotate</button>
        <button id="reset-button" class="control-button">Reset View</button>
        <button id="rotate-button" class="control-button">Rotate View 90Â°</button>
    </div>

    <div id="info">
        <strong>Simple Controls:</strong><br>
        - <strong>Rotate View:</strong> Left Mouse + Drag<br>
        - <strong>Zoom:</strong> Mouse Wheel / Pinch<br>
        - <strong>Pan View:</strong> Right Mouse + Drag<br>
        <br>
        *Note: Model movement (Drag Controls) is disabled for simplicity.*
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.163.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.163.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        
        let scene, camera, renderer, orbitControls;
        const loadedModels = [];
        
        // --- History System for Rotation ---
        const history = [];
        let historyIndex = -1;
        const MAX_HISTORY = 20;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x333333);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(2, 2, 5);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            document.body.appendChild(renderer.domElement);
            
            // --- BRIGHTER LIGHTING SETUP ---
            // Ambient Light (Overall softness)
            scene.add(new THREE.AmbientLight(0xffffff, 1.5)); 

            // Key Light (Main bright source)
            scene.add(new THREE.DirectionalLight(0xffffff, 5.0).position.set(5, 5, 5).normalize()); 

            // Fill Light (Softens shadows from Key Light)
            scene.add(new THREE.DirectionalLight(0xffffff, 3.0).position.set(-5, 5, 5).normalize()); 

            // Back Light (Separates model from background)
            scene.add(new THREE.DirectionalLight(0xffffff, 2.0).position.set(0, -5, -5).normalize()); 
            
            orbitControls = new OrbitControls(camera, renderer.domElement);
            orbitControls.enableDamping = true;
            
            // Add a listener to record manual orbit rotation
            orbitControls.addEventListener('end', recordManualOrbit);

            new RGBELoader().load('https://unpkg.com/three@0.163.0/examples/textures/equirectangular/venice_sunset_1k.hdr', (texture) => {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.environment = texture;
            });
            
            scene.add(new THREE.GridHelper(20, 20, 0x888888, 0x444444));

            // Attach all event listeners
            document.getElementById('file-input').addEventListener('change', onFileSelected);
            document.getElementById('clear-button').addEventListener('click', clearModels);
            document.getElementById('undo-button').addEventListener('click', undo);
            document.getElementById('redo-button').addEventListener('click', redo);
            document.getElementById('reset-button').addEventListener('click', resetView);
            document.getElementById('rotate-button').addEventListener('click', rotateView90);
            window.addEventListener('resize', onWindowResize);
            
            // Initial history state (default view)
            recordHistoryEntry(orbitControls.getAzimuthalAngle());
        }

        function animate() {
            requestAnimationFrame(animate);
            orbitControls.update();
            renderer.render(scene, camera);
        }

        function onFileSelected(event) {
            const files = event.target.files;
            if (files.length === 0) return;

            const loader = new GLTFLoader();
            
            clearModels(false); // Clear previous models, but keep history

            for (const file of files) {
                const url = URL.createObjectURL(file);
                loader.load(url, (gltf) => {
                    const model = gltf.scene;
                    scene.add(model);
                    loadedModels.push(model);
                    URL.revokeObjectURL(url);
                    
                    if (loadedModels.length === files.length) {
                        frameAllModels();
                        // Record the new framed view's rotation as the history start point
                        recordHistoryEntry(orbitControls.getAzimuthalAngle()); 
                    }
                }, undefined, (error) => {
                    console.error('An error happened while loading a model:', error);
                });
            }
        }
        
        // --- History & Control Functions ---

        function updateUndoRedoButtons() {
            document.getElementById('undo-button').disabled = historyIndex <= 0;
            document.getElementById('redo-button').disabled = historyIndex >= history.length - 1;
        }

        function recordManualOrbit() {
            const currentAngle = orbitControls.getAzimuthalAngle();
            if (historyIndex >= 0 && Math.abs(currentAngle - history[historyIndex]) < 0.001) return;
            
            recordHistoryEntry(currentAngle);
        }

        function recordHistoryEntry(angle) {
            if (historyIndex < history.length - 1) {
                history.splice(historyIndex + 1);
            }
            
            history.push(angle);
            
            if (history.length > MAX_HISTORY) {
                history.shift();
            } else {
                historyIndex++;
            }
            
            updateUndoRedoButtons();
        }

        function applyRotationFromHistory(angle) {
            const deltaAngle = angle - orbitControls.getAzimuthalAngle();
            orbitControls.object.rotation.y += deltaAngle;
            
            orbitControls.update();
            renderer.render(scene, camera);
            updateUndoRedoButtons();
        }

        function undo() {
            if (historyIndex <= 0) return;
            historyIndex--;
            applyRotationFromHistory(history[historyIndex]);
        }

        function redo() {
            if (historyIndex >= history.length - 1) return;
            historyIndex++;
            applyRotationFromHistory(history[historyIndex]);
        }
        
        function rotateView90() {
            const currentAngle = orbitControls.getAzimuthalAngle();
            const newAngle = currentAngle + Math.PI / 2;
            
            orbitControls.object.rotation.y += Math.PI / 2;
            orbitControls.update();

            recordHistoryEntry(newAngle);
        }

        function resetView() {
            // Reset orbit controls and camera
            orbitControls.reset();
            
            // Reset history to contain only the new default view
            history.length = 0;
            historyIndex = -1;
            recordHistoryEntry(orbitControls.getAzimuthalAngle());
        }

        function clearModels(clearHistory = true) {
            for (const model of loadedModels) {
                scene.remove(model);
                model.traverse((child) => {
                    if (child.isMesh) {
                        child.geometry.dispose();
                        if (child.material) {
                            const materials = Array.isArray(child.material) ? child.material : [child.material];
                            materials.forEach(m => m.dispose());
                        }
                    }
                });
            }
            loadedModels.length = 0;
            
            if (clearHistory) {
                resetView();
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- FIXED: Calculates the bounding box of ALL models and frames the camera ---
        function frameAllModels() {
            if (loadedModels.length === 0) return;

            // 1. Reset each model's position to the world origin (0, 0, 0)
            // This is the CRUCIAL fix to ensure the model is visible under the lights.
            for (const model of loadedModels) {
                model.position.set(0, 0, 0); 
            }

            // 2. Calculate the bounding box for all (now centered) models
            const box = new THREE.Box3();
            for (const model of loadedModels) {
                box.expandByObject(model);
            }

            // 3. Set the camera view based on the centered models
            const size = box.getSize(new THREE.Vector3()).length();
            const center = box.getCenter(new THREE.Vector3());

            orbitControls.target.copy(center);
            const scaleFactor = 1.5;
            const position = center.clone().add(
                new THREE.Vector3(size * scaleFactor, size * scaleFactor, size * scaleFactor)
            );
            
            camera.position.copy(position);
            camera.lookAt(center);
            camera.updateProjectionMatrix();
            orbitControls.update();
        }

        init();
        animate();
    </script>
</body>
</html>
