!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Interactive 3D Archaeology Viewer</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: linear-gradient(180deg, #111, #1a1a1a);
    color: white;
    font-family: "Segoe UI", sans-serif;
  }
  #toolbar {
    position: absolute;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 10px;
    padding: 8px 14px;
    background: rgba(0, 0, 0, 0.6);
    border-radius: 6px;
  }
  .btn {
    background: linear-gradient(90deg, #007bff, #00bfff);
    border: none;
    border-radius: 5px;
    color: white;
    font-weight: 600;
    padding: 8px 12px;
    cursor: pointer;
  }
  .btn:hover {
    background: linear-gradient(90deg, #00bfff, #007bff);
  }
  #frame {
    position: absolute;
    top: 40px;
    left: 40px;
    right: 40px;
    bottom: 40px;
    border: 4px solid #00bfff;
    border-radius: 8px;
    box-shadow: 0 0 25px rgba(0, 191, 255, 0.5);
    overflow: hidden;
  }
  canvas { display: block; width: 100%; height: 100%; }
</style>
</head>
<body>
  <div id="toolbar">
    <input type="file" id="file-input" accept=".glb,.gltf" multiple>
    <button id="reset-btn" class="btn">Reset</button>
    <button id="clear-btn" class="btn">Clear</button>
  </div>

  <div id="frame"><canvas id="webgl"></canvas></div>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.163.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.163.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { DragControls } from 'three/addons/controls/DragControls.js';

let scene, camera, renderer, orbit, drag;
let selectedObject = null;
const models = [];

init();
animate();

function init() {
  const canvas = document.getElementById('webgl');
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x1a1a1a);

  camera = new THREE.PerspectiveCamera(70, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
  camera.position.set(4, 3, 8);

  renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setSize(canvas.clientWidth, canvas.clientHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.outputColorSpace = THREE.SRGBColorSpace;

  // Lighting to keep brightness
  const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.8);
  const ambient = new THREE.AmbientLight(0xffffff, 1.8);
  scene.add(hemi, ambient);

  // Orbit control
  orbit = new OrbitControls(camera, renderer.domElement);
  orbit.enableDamping = true;

  // Reference grid
  scene.add(new THREE.GridHelper(30, 30, 0x555555, 0x333333));

  // Events
  document.getElementById('file-input').addEventListener('change', loadFiles);
  document.getElementById('reset-btn').addEventListener('click', resetView);
  document.getElementById('clear-btn').addEventListener('click', clearScene);
  window.addEventListener('resize', onResize);
  window.addEventListener('mousedown', onSelectClick);
}

function animate() {
  requestAnimationFrame(animate);
  orbit.update();
  renderer.render(scene, camera);
}

// Load models
function loadFiles(event) {
  const loader = new GLTFLoader();
  for (const file of event.target.files) {
    const url = URL.createObjectURL(file);
    loader.load(url, gltf => {
      const model = gltf.scene;
      model.traverse(child => {
        if (child.isMesh && child.material) {
          child.material.metalness = 0;
          child.material.roughness = 1;
          if (child.material.map) child.material.map.encoding = THREE.sRGBEncoding;
        }
      });
      model.position.x = models.length * 3;
      scene.add(model);
      models.push(model);
      URL.revokeObjectURL(url);
      fitCameraToAll();
      setupDragControls();
    });
  }
}

// Click detection & focus
function onSelectClick(event) {
  const mouse = new THREE.Vector2();
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  const raycaster = new THREE.Raycaster();
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(models, true);

  if (intersects.length > 0) {
    const picked = intersects[0].object;
    if (selectedObject !== picked) {
      if (selectedObject) deselectObject(selectedObject);
      selectObject(picked);
    }
  } else if (selectedObject) {
    deselectObject(selectedObject);
    selectedObject = null;
    fitCameraToAll();
  }
}

function selectObject(obj) {
  selectedObject = obj;
  obj.material.emissive = new THREE.Color(0x00bfff); // highlight
  focusOnObject(obj);
}

function deselectObject(obj) {
  if (obj.material && obj.material.emissive) obj.material.emissive.setHex(0x000000);
}

function focusOnObject(obj) {
  const box = new THREE.Box3().setFromObject(obj);
  const center = box.getCenter(new THREE.Vector3());
  const size = box.getSize(new THREE.Vector3()).length();

  // Center orbit on this piece
  orbit.target.copy(center);
  camera.position.copy(center.clone().add(new THREE.Vector3(size, size, size)));
  orbit.update();
}

// Camera fit to all models
function fitCameraToAll() {
  if (!models.length) return;
  const box = new THREE.Box3();
  models.forEach(m => box.expandByObject(m));
  const center = box.getCenter(new THREE.Vector3());
  const size = box.getSize(new THREE.Vector3()).length();
  orbit.target.copy(center);
  camera.position.copy(center.clone().add(new THREE.Vector3(size, size, size)));
  orbit.update();
}

// Enable dragging normally
function setupDragControls() {
  if (drag) drag.deactivate();
  drag = new DragControls(models, camera, renderer.domElement);
  drag.addEventListener('dragstart', () => orbit.enabled = false);
  drag.addEventListener('dragend', () => orbit.enabled = true);
}

function clearScene() {
  models.forEach(m => scene.remove(m));
  models.length = 0;
  selectedObject = null;
}

function resetView() {
  selectedObject = null;
  fitCameraToAll();
}

function onResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}
</script>
</body>
</html>
