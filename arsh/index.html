<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>3D Viewer (No Shadows, True Color)</title>
<style>
  body { margin: 0; overflow: hidden; background: #1a1a1a; color: #fff; }
  canvas { display: block; }
  #controls-container {
    position: absolute; top: 20px; left: 20px; z-index: 10;
    background: rgba(0,0,0,0.6); padding: 10px; border-radius: 5px;
    display: flex; gap: 10px;
  }
  .control-button {
    border: none; border-radius: 4px;
    padding: 8px 15px; background: #007bff; color: #fff;
  }
  .control-button:hover { background: #0056b3; }
</style>
</head>
<body>

<div id="controls-container">
  <input type="file" id="file-input" accept=".glb,.gltf" multiple />
  <button id="clear-button" class="control-button">Clear</button>
  <button id="undo-button" class="control-button" disabled>Undo</button>
  <button id="redo-button" class="control-button" disabled>Redo</button>
  <button id="reset-button" class="control-button">Reset</button>
  <button id="rotate-button" class="control-button">Rotate 90Â°</button>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.163.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.163.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

let scene, camera, renderer, orbitControls;
const loadedModels = [];
const history = [];
let historyIndex = -1;

init();
animate();

function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x202020);

  camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(3, 3, 6);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.NoToneMapping; // no tone mapping
  renderer.shadowMap.enabled = false;
  document.body.appendChild(renderer.domElement);

  // single global light (soft, neutral)
  const ambient = new THREE.AmbientLight(0xffffff, 2.0);
  scene.add(ambient);

  // ensure renderer brightness without shadow/directional contrast
  const fill = new THREE.HemisphereLight(0xffffff, 0xffffff, 1.5);
  scene.add(fill);

  orbitControls = new OrbitControls(camera, renderer.domElement);
  orbitControls.enableDamping = true;
  orbitControls.addEventListener('end', recordManualOrbit);

  document.getElementById('file-input').addEventListener('change', onFileSelected);
  document.getElementById('clear-button').addEventListener('click', clearModels);
  document.getElementById('undo-button').addEventListener('click', undo);
  document.getElementById('redo-button').addEventListener('click', redo);
  document.getElementById('reset-button').addEventListener('click', resetView);
  document.getElementById('rotate-button').addEventListener('click', rotateView90);
  window.addEventListener('resize', onWindowResize);

  recordHistoryEntry(orbitControls.getAzimuthalAngle());
}

function onFileSelected(event) {
  const files = event.target.files;
  if (files.length === 0) return;
  const loader = new GLTFLoader();
  clearModels(false);

  for (const file of files) {
    const url = URL.createObjectURL(file);
    loader.load(url, (gltf) => {
      const model = gltf.scene;

      model.traverse((child) => {
        if (child.isMesh && child.material) {
          // keep texture and color, disable reflections
          child.material.envMap = null;
          child.material.metalness = 0;
          child.material.roughness = 1;
          child.material.needsUpdate = true;
        }
      });

      scene.add(model);
      loadedModels.push(model);
      URL.revokeObjectURL(url);
      frameAllModels();
      recordHistoryEntry(orbitControls.getAzimuthalAngle());
    });
  }
}

function animate() {
  requestAnimationFrame(animate);
  orbitControls.update();
  renderer.render(scene, camera);
}

// rotation history functions (unchanged)
function recordManualOrbit() {
  const angle = orbitControls.getAzimuthalAngle();
  if (historyIndex >= 0 && Math.abs(angle - history[historyIndex]) < 0.001) return;
  recordHistoryEntry(angle);
}
function recordHistoryEntry(angle) {
  history.splice(historyIndex + 1);
  history.push(angle);
  historyIndex = history.length - 1;
  updateUndoRedoButtons();
}
function applyRotationFromHistory(angle) {
  const delta = angle - orbitControls.getAzimuthalAngle();
  orbitControls.object.rotation.y += delta;
  orbitControls.update();
}
function undo() { if (historyIndex > 0) applyRotationFromHistory(history[--historyIndex]); }
function redo() { if (historyIndex < history.length - 1) applyRotationFromHistory(history[++historyIndex]); }
function updateUndoRedoButtons() {
  document.getElementById('undo-button').disabled = historyIndex <= 0;
  document.getElementById('redo-button').disabled = historyIndex >= history.length - 1;
}
function rotateView90() {
  orbitControls.object.rotation.y += Math.PI / 2;
  orbitControls.update();
  recordHistoryEntry(orbitControls.getAzimuthalAngle());
}
function resetView() {
  orbitControls.reset();
  history.length = 0;
  historyIndex = -1;
  recordHistoryEntry(orbitControls.getAzimuthalAngle());
}
function clearModels(clearHistory = true) {
  for (const model of loadedModels) scene.remove(model);
  loadedModels.length = 0;
  if (clearHistory) resetView();
}
function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}
function frameAllModels() {
  if (!loadedModels.length) return;
  const box = new THREE.Box3();
  loadedModels.forEach(m => box.expandByObject(m));
  const size = box.getSize(new THREE.Vector3()).length();
  const center = box.getCenter(new THREE.Vector3());
  orbitControls.target.copy(center);
  camera.position.copy(center.clone().add(new THREE.Vector3(size, size, size)));
  camera.lookAt(center);
  orbitControls.update();
}
</script>
</body>
</html>
