<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Archaeological Assembly</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Three.js for 3D rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Load Orbit Controls for camera movement -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        /* Set the custom font and ensure full-screen coverage */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; background-color: #ffffff; margin: 0; overflow: hidden; }
        #app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        #three-container {
            flex-grow: 1;
            position: relative;
        }
    </style>
</head>
<body class="antialiased">

    <div id="app-container">
        <!-- Header & Status -->
        <header class="p-4 bg-gray-900 shadow-xl text-white flex justify-between items-center z-10">
            <h1 class="text-xl font-bold text-yellow-300">Archaeological Fragment Assembly (3D)</h1>
            <div id="status-box" class="px-4 py-2 bg-gray-700 rounded-full text-sm font-mono transition-all duration-300">
                Status: Ready to Assemble
            </div>
        </header>

        <!-- 3D Viewport -->
        <div id="three-container">
            <!-- 3D canvas will be injected here -->
        </div>

        <!-- Instructions -->
        <footer class="p-2 bg-gray-900 text-center text-gray-400 text-xs md:text-sm">
            Use **Mouse Drag** to rotate the camera. Use **Scroll** to zoom. **Click and Drag** a fragment to move it along the ground plane.
        </footer>
    </div>

<script>
    // --- Global Variables ---
    const THREE_CONTAINER = document.getElementById('three-container');
    const STATUS_BOX = document.getElementById('status-box');
    const SNAP_THRESHOLD = 0.5; // Distance in 3D units for snapping
    
    let scene, camera, renderer, controls;
    let raycaster, pointer, dragPlane;
    let activePiece = null;
    let offset = new THREE.Vector3();
    let pieces = [];
    let piecesSnapped = 0;

    // --- Artifact Data (Position, Type, Color) ---
    const artifactData = [
        { id: 'partA', geometry: 'Box', color: 0xcc9966, position: new THREE.Vector3(5, 0.5, 5), target: new THREE.Vector3(0, 0.5, 0) },
        { id: 'partB', geometry: 'Sphere', color: 0x996633, position: new THREE.Vector3(-5, 0.5, -5), target: new THREE.Vector3(0, 1.5, 0) },
        { id: 'partC', geometry: 'Cylinder', color: 0x663300, position: new THREE.Vector3(5, 0.5, -5), target: new THREE.Vector3(0, 2.5, 0) }
    ];

    // --- Core Functions ---

    /**
     * Initializes the Three.js scene, camera, and renderer.
     */
    function initThree() {
        // Scene (White background for "archaeologist" workspace)
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        // Camera
        camera = new THREE.PerspectiveCamera(50, THREE_CONTAINER.clientWidth / THREE_CONTAINER.clientHeight, 0.1, 1000);
        camera.position.set(10, 8, 10);

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(THREE_CONTAINER.clientWidth, THREE_CONTAINER.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        THREE_CONTAINER.appendChild(renderer.domElement);

        // Controls
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; 
        controls.dampingFactor = 0.05;
        controls.minDistance = 5;
        controls.maxDistance = 50;

        // Lighting
        scene.add(new THREE.AmbientLight(0x606060));
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);
        
        // Ground Grid (Subtle gray grid for visual context)
        const gridHelper = new THREE.GridHelper(20, 20, 0xaaaaaa, 0xcccccc);
        gridHelper.position.y = 0.01; // Slightly above zero to prevent Z-fighting
        scene.add(gridHelper);

        // Setup Raycaster for interaction
        raycaster = new THREE.Raycaster();
        pointer = new THREE.Vector2();

        // Dragging Plane (Fixed at Y=0, simulating a workbench)
        dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);

        // Initialize Artifacts
        createArtifacts();

        // Event Listeners
        renderer.domElement.addEventListener('pointerdown', onPointerDown);
        renderer.domElement.addEventListener('pointermove', onPointerMove);
        renderer.domElement.addEventListener('pointerup', onPointerUp);
        window.addEventListener('resize', onWindowResize, false);
    }

    /**
     * Creates all 3D artifact fragments and their ghost targets.
     */
    function createArtifacts() {
        artifactData.forEach(data => {
            let geometry, material;

            // 1. Create the Piece (Draggable Fragment)
            switch (data.geometry) {
                case 'Box':
                    geometry = new THREE.BoxGeometry(1, 1, 1);
                    break;
                case 'Sphere':
                    geometry = new THREE.SphereGeometry(1, 16, 16);
                    geometry.scale(1, 0.5, 1); // Flattened sphere
                    break;
                case 'Cylinder':
                    geometry = new THREE.CylinderGeometry(0.7, 0.7, 2, 32);
                    break;
            }

            material = new THREE.MeshLambertMaterial({ color: data.color, wireframe: false, flatShading: true });
            const piece = new THREE.Mesh(geometry, material);
            piece.position.copy(data.position);
            piece.userData = { id: data.id, target: data.target, isPiece: true, snapped: false };
            scene.add(piece);
            pieces.push(piece);


            // 2. Create the Target (Ghost Outline)
            const targetMaterial = new THREE.MeshBasicMaterial({ 
                color: data.color, 
                wireframe: true, 
                transparent: true, 
                opacity: 0.2 
            });
            const targetMesh = new THREE.Mesh(geometry, targetMaterial);
            targetMesh.position.copy(data.target);
            targetMesh.userData = { isTarget: true, pieceId: data.id };
            scene.add(targetMesh);
        });
        updateStatus(`Place the ${artifactData.length} fragments into their outlines.`);
    }

    /**
     * Handles the pointer down event for dragging.
     */
    function onPointerDown(event) {
        // 1. Update pointer position
        pointer.x = (event.clientX / THREE_CONTAINER.clientWidth) * 2 - 1;
        pointer.y = -(event.clientY / THREE_CONTAINER.clientHeight) * 2 + 1;

        // 2. Raycast to find intersection
        raycaster.setFromCamera(pointer, camera);
        const intersects = raycaster.intersectObjects(pieces.filter(p => !p.userData.snapped));

        if (intersects.length > 0) {
            controls.enabled = false; // Disable orbit controls while dragging
            activePiece = intersects[0].object;

            // Calculate offset between piece center and click point on the drag plane
            raycaster.ray.intersectPlane(dragPlane, offset);
            offset.sub(activePiece.position);

            renderer.domElement.style.cursor = 'grabbing';
            activePiece.material.emissive.setHex(0x333333); // Highlight piece
        }
    }

    /**
     * Handles the pointer move event for dragging.
     */
    function onPointerMove(event) {
        if (!activePiece) return;

        // 1. Update pointer position
        pointer.x = (event.clientX / THREE_CONTAINER.clientWidth) * 2 - 1;
        pointer.y = -(event.clientY / THREE_CONTAINER.clientHeight) * 2 + 1;

        // 2. Raycast the new pointer position against the drag plane
        raycaster.setFromCamera(pointer, camera);
        const intersection = new THREE.Vector3();
        raycaster.ray.intersectPlane(dragPlane, intersection);

        // 3. Update piece position (move it by the intersection point minus the initial offset)
        activePiece.position.copy(intersection.sub(offset));
        
        // Keep the piece slightly elevated above the plane (Y=0)
        activePiece.position.y = activePiece.geometry.boundingSphere.radius; 
    }

    /**
     * Handles the pointer up event for snapping and releasing.
     */
    function onPointerUp() {
        if (!activePiece) return;

        controls.enabled = true; // Re-enable orbit controls
        renderer.domElement.style.cursor = 'grab';
        activePiece.material.emissive.setHex(0x000000); // Remove highlight

        checkSnap(activePiece);
        activePiece = null;
    }

    /**
     * Checks if the released piece is close enough to its target to snap.
     */
    function checkSnap(piece) {
        if (piece.userData.snapped) return;

        const targetPosition = piece.userData.target;
        const currentPosition = piece.position;

        if (currentPosition.distanceTo(targetPosition) < SNAP_THRESHOLD) {
            // SNAP SUCCESS!
            
            // 1. Lock the piece to the target's exact position
            piece.position.copy(targetPosition);

            // 2. Mark as snapped and change appearance
            piece.userData.snapped = true;
            piece.material.color.set(piece.material.color.getHex() * 0.8); // Dim slightly to show it's fixed
            piece.material.opacity = 1;

            // 3. Find and hide the ghost target
            const targetId = piece.userData.id;
            scene.children.find(c => c.userData.pieceId === targetId).visible = false;

            // 4. Update status
            piecesSnapped++;
            if (piecesSnapped === artifactData.length) {
                updateStatus('ASSEMBLY COMPLETE! The artifact is whole!', 'bg-green-600 text-white shadow-lg');
            } else {
                updateStatus('Piece snapped! Keep assembling.', 'bg-yellow-400 text-gray-800');
            }
        }
    }

    /**
     * Updates the status box with a message and optional styling.
     */
    function updateStatus(message, classes = 'bg-gray-700 text-white') {
        STATUS_BOX.textContent = `Status: ${message}`;
        STATUS_BOX.className = `px-4 py-2 rounded-full text-sm font-mono transition-all duration-300 ${classes}`;
    }

    /**
     * Handles window resizing.
     */
    function onWindowResize() {
        camera.aspect = THREE_CONTAINER.clientWidth / THREE_CONTAINER.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(THREE_CONTAINER.clientWidth, THREE_CONTAINER.clientHeight);
    }

    // --- Initialization ---

    window.onload = function () {
        initThree();
        animate();
    }

    function animate() {
        requestAnimationFrame(animate);
        controls.update(); // only required if controls.enableDamping is true
        renderer.render(scene, camera);
    }
</script>
</body>

