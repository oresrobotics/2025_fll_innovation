

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GLB 3D Importer</title>
    <!-- Load Tailwind CSS for aesthetic styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Set up the body and viewer to take up the full viewport */
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrolling */
            font-family: 'Inter', sans-serif;
            background-color: #0d1117; /* Dark background for a premium feel */
        }
        #viewer-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        /* Style the message box */
        #message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 1.5rem 2.5rem;
            background-color: rgba(30, 41, 59, 0.95);
            color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.5);
            z-index: 10;
            min-width: 300px;
            text-align: center;
            backdrop-filter: blur(5px);
        }
        /* Ensure the canvas covers the container */
        canvas {
            display: block;
        }
    </style>
    <!-- Load Three.js core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Load GLTFLoader for handling .glb and .gltf files -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <!-- Load OrbitControls for camera interaction (rotate, pan, zoom) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div id="viewer-container">
        <!-- The canvas will be appended here -->
    </div>

    <!-- Controls Panel: Floating at the bottom center -->
    <div id="controls-panel" class="absolute bottom-4 left-1/2 transform -translate-x-1/2 bg-slate-800 p-3 rounded-xl shadow-2xl flex flex-col sm:flex-row items-center space-y-2 sm:space-y-0 sm:space-x-4 z-20 border border-indigo-500/50">
        <label for="file-input" class="cursor-pointer bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-lg transition duration-300 shadow-md active:scale-95">
            Load New .GLB File
        </label>
        <input type="file" id="file-input" accept=".glb, .gltf" class="hidden">
        <p class="text-xs text-slate-300 hidden sm:block">
            Controls: Click/Drag to **Rotate**, Scroll to **Zoom**
        </p>
    </div>

    <!-- Message box for loading status and instructions -->
    <div id="message-box" class="flex flex-col items-center">
        <div id="loading-spinner" class="animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-400 mb-4 hidden"></div>
        <div id="message-content" class="text-xl font-bold">Please load a .GLB or .GLTF file.</div>
    </div>

    <script>
        // Global variables for the three.js scene
        let scene, camera, renderer, controls, model, container;
        const messageBox = document.getElementById('message-box');
        const messageContent = document.getElementById('message-content');
        const loadingSpinner = document.getElementById('loading-spinner');
        const fileInput = document.getElementById('file-input');
        
        // This is used to track if the animation loop has started
        let isAnimating = false;

        /**
         * Initializes the Three.js scene, camera, renderer, and lighting.
         */
        function initScene() {
            container = document.getElementById('viewer-container');

            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a202c); 

            // Camera setup
            camera = new THREE.PerspectiveCamera(
                50, 
                window.innerWidth / window.innerHeight, 
                0.1, 
                1000 
            );
            camera.position.set(0, 0, 5); 

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            container.appendChild(renderer.domElement);
            
            // Controls setup (OrbitControls allows user to interact with the camera)
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // Smooth inertia for rotation
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = true; // Allow panning

            // Lighting setup
            // 1. Hemisphere light (soft ambient light)
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
            hemiLight.position.set(0, 20, 0);
            scene.add(hemiLight);

            // 2. Directional light (for shadows and highlights)
            const dirLight = new THREE.DirectionalLight(0xffffff, 2.0);
            dirLight.position.set(5, 5, 5);
            scene.add(dirLight);

            // Handle window resizing
            window.addEventListener('resize', onWindowResize, false);
        }

        /**
         * Clears the previous model from the scene, if one exists, to prevent memory leaks.
         */
        function clearScene() {
            if (model) {
                scene.remove(model);
                // Dispose of geometries and materials to free GPU memory
                model.traverse(function(object) {
                    if (object.isMesh) {
                        if (object.geometry) object.geometry.dispose();
                        if (object.material) {
                            const materials = Array.isArray(object.material) ? object.material : [object.material];
                            materials.forEach(m => {
                                // Dispose of texture maps if they exist
                                for (const key in m) {
                                    if (m[key] && m[key].isTexture) {
                                        m[key].dispose();
                                    }
                                }
                                m.dispose();
                            });
                        }
                    }
                });
                model = null;
            }
        }

        /**
         * Loads the GLB/GLTF file content from an ArrayBuffer using GLTFLoader.parse.
         */
        function loadModelFromBuffer(buffer) {
            clearScene(); // Clear previous model
            messageBox.classList.remove('hidden');
            loadingSpinner.classList.remove('hidden');
            messageContent.textContent = 'Parsing 3D Model...';
            
            const loader = new THREE.GLTFLoader();

            loader.parse(
                buffer,
                '', // Base path is empty since we are loading from memory
                // On Load Success
                function (gltf) {
                    model = gltf.scene;
                    scene.add(model);
                    console.log('Model loaded successfully.', model);

                    // --- Auto-center and Re-frame Logic ---
                    const box = new THREE.Box3().setFromObject(model);
                    const size = box.getSize(new THREE.Vector3());
                    const center = box.getCenter(new THREE.Vector3());
                    
                    // Reposition the model so its center is at the scene origin (0,0,0)
                    model.position.sub(center); 
                    controls.target.set(0, 0, 0); // Set controls target to the new center

                    // Adjust camera distance based on model size for proper framing
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const fov = camera.fov * (Math.PI / 180);
                    let cameraDistance = Math.abs(maxDim / (2 * Math.tan(fov / 2)));
                    cameraDistance *= 1.5; // Add some padding

                    // Reset camera position for a clean start
                    camera.position.set(cameraDistance, cameraDistance, cameraDistance);
                    camera.lookAt(model.position);
                    controls.update(); 
                    
                    // Hide loading message
                    messageBox.classList.add('hidden');
                    
                    // Start animation loop only once
                    if (!isAnimating) { 
                       animate(); 
                       isAnimating = true;
                    }
                },
                // On Error
                function (error) {
                    console.error('An error occurred parsing the model:', error);
                    messageContent.textContent = 'Error parsing model. Please check the file format.';
                    loadingSpinner.classList.add('hidden');
                    messageBox.classList.remove('hidden');
                }
            );
        }

        /**
         * Handles the file input change event, reading the file into memory.
         */
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            messageBox.classList.remove('hidden');
            loadingSpinner.classList.remove('hidden');
            messageContent.textContent = `Reading ${file.name}...`;

            const reader = new FileReader();

            reader.onload = function(e) {
                // FileReader result is the ArrayBuffer needed by GLTFLoader.parse
                loadModelFromBuffer(e.target.result);
            };

            reader.onerror = function(e) {
                console.error("FileReader failed:", e);
                messageContent.textContent = 'Failed to read file.';
                loadingSpinner.classList.add('hidden');
            };

            // Read the file as an ArrayBuffer
            reader.readAsArrayBuffer(file);
        }


        /**
         * The main animation loop.
         */
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // Update controls for smooth damping effect
            renderer.render(scene, camera);
        }

        /**
         * Handles resizing the canvas when the window size changes.
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Execution ---
        window.onload = function() {
            // Initialize the scene
            initScene();

            // Set up event listener for the file input
            fileInput.addEventListener('change', handleFileSelect, false);
        };

    </script>
</body>
</html>














    

