<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>GLB Viewer (Fixed)</title>
  <style>
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: #111;
      display: flex;
      flex-direction: column;
    }
    #toolbar {
      display: flex;
      gap: 12px;
      align-items: center;
      padding: 10px 12px;
      background: #1e1e1e;
      color: #ddd;
      border-bottom: 1px solid #2a2a2a;
    }
    .btn {
      padding: 8px 12px;
      background: #3b82f6;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
    }
    .btn:hover { background: #2563eb; }
    #viewer {
      position: relative;
      flex: 1 1 auto;
      min-height: 0;
      background: #e9ecef;
      overflow: hidden;
    }
    #dropHint {
      position: absolute; inset: 0;
      display: flex; align-items: center; justify-content: center;
      color: #4b5563; pointer-events: none;
      font-size: 14px; text-align: center;
    }
    #file { display: none; }
  </style>
</head>
<body>
  <div id="toolbar">
    <button class="btn" id="openBtn">Open GLBs</button>
    <button class="btn" id="rotLeft">⟲ Rotate -15°</button>
    <button class="btn" id="rotRight">⟳ Rotate +15°</button>
    <span id="status">Drop .glb files here or click Open GLBs</span>
    <span id="selectedLabel" style="margin-left:auto">Selected: None</span>
    <input type="file" id="file" accept=".glb,.gltf" multiple />
  </div>
  <div id="viewer">
    <div id="dropHint">Drop .glb here • Uses proper PBR lighting and color space</div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/examples/jsm/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
    import { GLTFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/DRACOLoader.js';
    import { KTX2Loader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/KTX2Loader.js';
    import { RoomEnvironment } from 'https://unpkg.com/three@0.160.0/examples/jsm/environments/RoomEnvironment.js';
    import { TransformControls } from 'three/examples/jsm/controls/TransformControls.js';

    const container = document.getElementById('viewer');
    const statusEl = document.getElementById('status');
    const dropHint = document.getElementById('dropHint');
    const openBtn = document.getElementById('openBtn');
    const fileInput = document.getElementById('file');
    const selectedLabel = document.getElementById('selectedLabel');

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    renderer.outputColorSpace = THREE.SRGBColorSpace; // critical for correct texture color
    container.appendChild(renderer.domElement);

    // Scene & camera
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xe9ecef);

    const camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.01, 2000);
    camera.position.set(3, 2, 5);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // Environment lighting (IBL) similar to Khronos viewer behavior
    const pmrem = new THREE.PMREMGenerator(renderer);
    scene.environment = pmrem.fromScene(new RoomEnvironment(), 0.04).texture;

    // Add soft lights for extra fill
    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
    hemi.position.set(0, 20, 0);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(5, 10, 7);
    scene.add(dir);

    // GLTF loader with optional decoders
    const loader = new GLTFLoader();
    const draco = new DRACOLoader();
    draco.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
    loader.setDRACOLoader(draco);

    const ktx2 = new KTX2Loader().setTranscoderPath('https://unpkg.com/three@0.160.0/examples/jsm/libs/basis/').detectSupport(renderer);
    loader.setKTX2Loader(ktx2);

    // Multi-piece state
    const raycastTargets = []; // meshes used for hit testing / selection
    let pieces = [];
    let selected = null;
    let selectedBox = null;
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();
    let pointerDown = null;
    let dragging = false;
    let isTransformDragging = false;
    const dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
    const dragOffset = new THREE.Vector3();
    const dragIntersect = new THREE.Vector3();

    let current;

    function clearModel() {
      if (!current) return;
      scene.remove(current);
      current.traverse((obj) => {
        if (obj.isMesh) {
          obj.geometry?.dispose?.();
          if (obj.material) {
            const mats = Array.isArray(obj.material) ? obj.material : [obj.material];
            mats.forEach((m) => {
              for (const key in m) {
                const val = m[key];
                if (val && val.isTexture) val.dispose();
              }
              m.dispose?.();
            });
          }
        }
      });
      current = undefined;
    }

    function frameObject(object) {
      const box = new THREE.Box3().setFromObject(object);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z) || 1;

      const distance = maxDim / (2 * Math.tan(THREE.MathUtils.degToRad(camera.fov) / 2));
      const newPos = center.clone().add(new THREE.Vector3(1, 1, 1).normalize().multiplyScalar(distance * 1.2));

      camera.near = Math.max(0.01, distance / 100);
      camera.far = distance * 100;
      camera.updateProjectionMatrix();

      camera.position.copy(newPos);
      controls.target.copy(center);
      controls.update();
    }

    // --- Selection & dragging helpers ---
    function getPieceGroup(obj) {
      if (!obj) return null;
      if (obj.userData && obj.userData.piece) return obj;
      return obj.parent ? getPieceGroup(obj.parent) : null;
    }

    function setSelected(obj) {
      const piece = getPieceGroup(obj);
      if (selectedBox) {
        scene.remove(selectedBox);
        selectedBox = null;
      }
      selected = piece;
      if (selected) {
        selectedBox = new THREE.BoxHelper(selected, 0x0080ff);
        scene.add(selectedBox);
        selectedLabel.textContent = 'Selected: ' + (selected.name || '(unnamed)');
        transform.attach(selected);
      } else {
        selectedLabel.textContent = 'Selected: None';
        transform.detach();
      }
    }

    // Transform gizmo for 3D translate/rotate/scale
    const transform = new TransformControls(camera, renderer.domElement);
    scene.add(transform);
    transform.addEventListener('dragging-changed', (e) => {
      isTransformDragging = e.value;
      controls.enabled = !e.value && !dragging;
    });

    function addGltfToScene(gltf, name) {
      const root = gltf.scene;
      // Create wrapper with pivot centered on geometry
      const box = new THREE.Box3().setFromObject(root);
      const center = box.getCenter(new THREE.Vector3());
      const wrapper = new THREE.Group();
      wrapper.name = name || 'piece';
      wrapper.userData.piece = true;
      root.position.sub(center);
      wrapper.add(root);
      scene.add(wrapper);

      pieces.push({ group: wrapper, name });

      // Add mesh descendants to raycast targets and tag with piece group
      root.traverse((child) => {
        if (child.isMesh) {
          child.userData.piece = wrapper;
          raycastTargets.push(child);
        }
      });

      frameObject(wrapper);
      setSelected(wrapper);
      statusEl.textContent = `Loaded: ${name}`;
      dropHint.style.display = 'none';
    }

    function rotateSelected(delta) {
      if (!selected) return;
      selected.rotation.y += delta;
      if (selectedBox) selectedBox.update();
    }

    async function loadArrayBuffer(arrayBuffer, name = 'model.glb') {
      statusEl.textContent = `Loading: ${name}`;
      try {
        loader.parse(arrayBuffer, '', (gltf) => {
          addGltfToScene(gltf, name);
        }, (err) => {
          console.error('GLTF parse error:', err);
          statusEl.textContent = `Error loading ${name}`;
          alert('Failed to parse GLB/GLTF: ' + err.message);
        });
      } catch (e) {
        console.error(e);
        statusEl.textContent = `Error loading ${name}`;
        alert('Failed to load model: ' + e.message);
      }
    }

    // UI handlers
    openBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', (e) => {
      const files = Array.from(e.target.files || []);
      const glbs = files.filter(f => /\.glb$/i.test(f.name));
      glbs.forEach(file => file.arrayBuffer().then((ab) => loadArrayBuffer(ab, file.name)));
      fileInput.value = '';
    });

    // Rotate buttons and keyboard shortcuts
    const ROT_STEP = Math.PI / 12; // 15°
    document.getElementById('rotLeft').addEventListener('click', () => rotateSelected(-ROT_STEP));
    document.getElementById('rotRight').addEventListener('click', () => rotateSelected(ROT_STEP));
    window.addEventListener('keydown', (e) => {
      if (!selected) return;
      if (e.key === 'q' || e.key === 'Q' || e.key === 'ArrowLeft') rotateSelected(-ROT_STEP);
      if (e.key === 'e' || e.key === 'E' || e.key === 'ArrowRight') rotateSelected(ROT_STEP);
    });

    // TransformControls mode buttons
    const modeButtons = {
      move: document.createElement('button'),
      rotate: document.createElement('button'),
      scale: document.createElement('button'),
    };
    modeButtons.move.className = 'btn';
    modeButtons.move.textContent = 'Move';
    modeButtons.rotate.className = 'btn';
    modeButtons.rotate.textContent = 'Rotate';
    modeButtons.scale.className = 'btn';
    modeButtons.scale.textContent = 'Scale';
    const toolbar = document.getElementById('toolbar');
    toolbar.insertBefore(modeButtons.scale, document.getElementById('status'));
    toolbar.insertBefore(modeButtons.rotate, modeButtons.scale);
    toolbar.insertBefore(modeButtons.move, modeButtons.rotate);
    modeButtons.move.addEventListener('click', () => transform.setMode('translate'));
    modeButtons.rotate.addEventListener('click', () => transform.setMode('rotate'));
    modeButtons.scale.addEventListener('click', () => transform.setMode('scale'));

    // Uniform scale slider
    const scaleSlider = document.createElement('input');
    scaleSlider.type = 'range';
    scaleSlider.min = '0.1';
    scaleSlider.max = '3';
    scaleSlider.step = '0.01';
    scaleSlider.value = '1';
    scaleSlider.style.marginLeft = '12px';
    document.getElementById('toolbar').insertBefore(scaleSlider, document.getElementById('status'));
    scaleSlider.addEventListener('input', () => {
      if (!selected) return;
      const s = parseFloat(scaleSlider.value);
      selected.scale.set(s, s, s);
      if (selectedBox) selectedBox.update();
    });

    // Click-select & free-drag on ground plane with mouse/trackpad
    renderer.domElement.addEventListener('pointerdown', (e) => {
      const rect = renderer.domElement.getBoundingClientRect();
      pointer.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      pointer.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(pointer, camera);
      const hits = raycaster.intersectObjects(raycastTargets, true);
      if (hits.length) {
        const hitPiece = getPieceGroup(hits[0].object);
        setSelected(hitPiece);
        // Start drag on selected piece
        dragPlane.setFromNormalAndCoplanarPoint(new THREE.Vector3(0, 1, 0), selected.position);
        raycaster.ray.intersectPlane(dragPlane, dragIntersect);
        if (dragIntersect) {
          dragOffset.copy(dragIntersect).sub(selected.position);
          dragging = true;
          controls.enabled = false;
        }
      } else {
        setSelected(null);
      }
    });

    renderer.domElement.addEventListener('pointermove', (e) => {
      if (!dragging || !selected || isTransformDragging) return;
      const rect = renderer.domElement.getBoundingClientRect();
      pointer.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      pointer.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(pointer, camera);
      if (raycaster.ray.intersectPlane(dragPlane, dragIntersect)) {
        const target = dragIntersect.clone().sub(dragOffset);
        selected.position.set(target.x, selected.position.y, target.z); // move in XZ
        if (selectedBox) selectedBox.update();
      }
    });

    window.addEventListener('pointerup', () => {
      if (dragging) {
        dragging = false;
        controls.enabled = !isTransformDragging;
      }
    });

    // Drag & drop
    ['dragenter', 'dragover'].forEach((evt) =>
      container.addEventListener(evt, (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; })
    );
    container.addEventListener('drop', (e) => {
      e.preventDefault();
      const files = Array.from(e.dataTransfer.files || []);
      const glbs = files.filter(f => /\.glb$/i.test(f.name));
      glbs.forEach(file => file.arrayBuffer().then((ab) => loadArrayBuffer(ab, file.name)));
    });

    // Attempt to auto-load a sibling GLB when served over http(s)
    const defaultName = 'artifact2-mode_6_8pcs.glb';
    if (location.protocol.startsWith('http')) {
      loader.load(defaultName, (gltf) => {
        addGltfToScene(gltf, defaultName);
      }, undefined, (err) => {
        console.warn('Auto-load failed:', err?.message || err);
      });
    }

    // Resize
    function onResize() {
      const w = container.clientWidth;
      const h = container.clientHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    }
    window.addEventListener('resize', onResize);

    // Render loop
    (function animate() {
      requestAnimationFrame(animate);
      controls.update();
      if (selectedBox) selectedBox.update();
      renderer.render(scene, camera);
    })();
  </script>
</body>
</html>
